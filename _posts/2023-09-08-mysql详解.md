---
layout: single
title: mysql详解
date: 2023-07-16 08:45:17
excerpt: mysql
categories:
- mysql八股
tags:
- mysql
- 事务
- 日志
---

{% include toc title = "目錄" %}



## InnoDB与MyISAM的区别？
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
InnoDB 是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB 是默认的 MySQL 引擎。
特点：
- DML 操作遵循 ACID 模型，支持**事务**
- **行级锁**，提高并发访问性能
- 支持**外键**约束，保证数据的完整性和正确性

MyISAM 是 MySQL 早期的默认存储引擎。
特点：
- 不支持事务，不支持外键
- 支持表锁，不支持行锁
- 访问速度快
## 索引及其优缺点？

索引是帮助 MySQL **高效获取数据**的**数据结构（有序）**。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查询算法，这种数据结构就是索引。
优缺点：
优点：
- 提高数据检索效率，降低数据库的IO成本
- 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗
缺点：
- 索引列也是要占用空间的
- 索引大大提高了查询效率，但降低了更新的速度，比如 INSERT、UPDATE、DELETE
## 索引的结构？
不同的存储引擎索引的结构不同

|索引结构|描述|
|---|---|
|B+Tree|最常见的索引类型，大部分引擎都支持B+树索引|
|Hash|底层数据结构是用哈希表实现，只有精确匹配索引列的查询才有效，不支持范围查询|
|R-Tree(空间索引)|空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少|
|Full-Text(全文索引)|是一种通过建立倒排索引，快速匹配文档的方式，类似于 Lucene, Solr, ES|



|索引|InnoDB|MyISAM|Memory|
|---|---|---|---|
|B+Tree索引|支持|支持|支持|
|Hash索引|不支持|不支持|支持|
|R-Tree索引|不支持|支持|不支持|
|Full-text|5.6版本后支持|支持|不支持|


### **B树的生成过程**

![](Pasted%20image%2020230902154348.png)

### **B+树的生成过程**
![](Pasted%20image%2020230902160137.png)
区别：
1. 所有的数据都在叶子节点
2. 形成一个单向链表
###  **hash索引**
![](Pasted%20image%2020230902164857.png)

特点：
- Hash索引只能用于对等比较（=、in），不支持范围查询（between、>、<、…）
- 无法利用索引完成排序操作
- 查询效率高，通常只需要一次检索就可以了，效率通常要高于 B+Tree 索引
存储引擎支持：
- Memory
- InnoDB: 具有自适应hash功能，hash索引是存储引擎根据 B+Tree 索引在指定条件下自动构建的

## 为什么 InnoDB 存储引擎选择使用 B+Tree 索引结构？

- 相对于二叉树，层级更少，搜索效率高
- 对于 B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针也跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低
- 相对于 Hash 索引，B+Tree 支持范围匹配及排序操作

## 索引的分类
| 分类                                  | 含义                            | 特点           | 关键字      |
|-------------------------------------|-------------------------------|--------------|----------|
| 主键索引                                | 针对于表中主键创建的索引                  | 默认自动创建，只能有一个 | PRIMARY  |
| 唯一索引                                | 避免同一个表中某数据列中的值重复              | 可以有多个        | UNIQUE   |
| 常规索引                                | 快速定位特定数据                      | 可以有多个        |          |
| 全文索引                                | 全文索引查找的是文本中的关键词，而不是比较索引中的值    | 可以有多个        | FULLTEXT |

 在 InnoDB 存储引擎中，根据索引的存储形式，又可以分为以下两种： 

| 分类                                  | 含义                            | 特点           |
|-------------------------------------|-------------------------------|--------------|
| 聚集索引(Clustered Index)               | 将数据存储与索引放一块，索引结构的叶子节点保存了行数据   | 必须有，而且只有一个   |
| 二级索引(Secondary Index)               | 将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键 | 可以存在多个       |

![](Pasted%20image%2020230902202600.png)

![](Pasted%20image%2020230902203022.png)

## 索引的使用规则？
### １.最左前缀原则 使用最左边的索引
**为什么会最左原则，就是因为 B+树 是根据最左边的字段构建的**
如果索引关联了多列（联合索引），要遵守最左前缀法则，最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。 如果跳跃某一列，索引将部分失效（后面的字段索引失效）。

联合索引中，出现范围查询（<, >），范围查询右侧的列索引失效。可以用>=或者<=来规避索引失效问题。
![](Pasted%20image%2020230902214905.png)
**1. 范围查询导致索引失效 使用>=代替>**
如果创建了一个 (a, b) 联合索引
Q1: select * from t_table where a > 1 and b = 2，b没有使用联合索引
Q2: select * from t_table where a >= 1 and b = 2，*相当于从a=1 and b=2开始查询 而不是a=1之后再查询*


### 索引失效情况
1. 在索引列上进行运算操作，索引将失效。如：`explain select * from tb_user where substring(phone, 10, 2) = '15';`
2. 字符串类型字段使用时，不加引号，索引将失效。如：`explain select * from tb_user where phone = 17799990015;`，此处phone的值没有加引号
3. 模糊查询中，如果仅仅是尾部模糊匹配，索引不会是失效；如果是头部模糊匹配，索引失效。如：`explain select * from tb_user where profession like '%工程';`，前后都有 % 也会失效。
4. 用 or 分割开的条件，如果 or 其中一个条件的列没有索引，那么涉及的索引都不会被用到。
5. 如果 MySQL 评估使用索引比全表更慢，则不使用索引。

### 覆盖索引
尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能找到），减少 select *
![](Pasted%20image%2020230903171241.png)
![](Pasted%20image%2020230903171321.png)
### 前缀索引 当索引很长时截取部分作为索引
当字段类型为字符串（varchar, text等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率，此时可以只降字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。

语法：`create index idx_xxxx on table_name(columnn(n));`  
前缀长度：可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。
![](Pasted%20image%2020230903171350.png)
#### 单列索引&联合索引

单列索引：即一个索引只包含单个列  
联合索引：即一个索引包含了多个列  
在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。

### 设计原则
1. 针对于数据量较大（百万级），且查询比较频繁的表建立索引
2. 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引
3. 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高
4. 如果是字符串类型的字段，字段长度较长，可以针对于字段的特点，建立前缀索引
5. 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率
6. 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价就越大，会影响增删改的效率
7. 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询

## sql优化
1. **插入优化**
普通插入：
1. 采用批量插入（一次插入的数据不建议超过1000条）
2. 手动提交事务
3. **主键顺序插入**

大批量插入：  
如果一次性需要插入大批量数据，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的**load指令插入**。
`# 执行load指令将准备好的数据，加载到表结构中`
`load data local infile '/root/sql1.log' into table 'tb_user' fields terminated by ',' lines terminated by '\n';`

2. **主键优化**
页分裂：
![](Pasted%20image%2020230903212506.png)
页合并：
![](Pasted%20image%2020230903212905.png)
**主键规则**
- 满足业务需求的情况下，尽量降低主键的长度
- 插入数据时，尽量选择顺序插入，选择使用 AUTO_INCREMENT 自增主键
- 尽量不要使用 UUID 做主键或者是其他的自然主键，如身份证号
- 业务操作时，避免对主键的修改

3. **order by 优化**
1. Using filesort：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区 sort buffer 中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序
2. Using index：通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高

- 根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则
- 尽量使用覆盖索引
- 多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC）
- 如果不可避免出现filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size（默认256k）
![](Pasted%20image%2020230903214430.png)
4.  **group by优化**

- 在分组操作时，可以通过索引来提高效率
- 分组操作时，索引的使用也是满足最左前缀法则的
如索引为`idx_user_pro_age_stat`，则句式可以是`select ... where profession order by age`，这样也符合最左前缀法则

5. **limit优化**

1.先满足覆盖索引,将要查询的记录的ids集合查询出来.
2.然后将上面查询出来的表作为子表,进行子查询...这样走的是主键索引,会很快
![](Pasted%20image%2020230903220114.png)
limit的原理:
server层会调用存储引擎层提供的接口,查询出来所有数据,存储到server层的结果集中,并抛弃掉前面不需要的数据然后返回给客户端....
**eg: limit 200000,10  ===>  需要调用引擎层的接口查询出来前200010条的所有数据并返回给server层,然后由server层再抛弃掉前200000条数据,只返回后10条給客户端....**

所以说从引擎层获取许多无用的数据然后又抛弃掉,这是非常耗时的!

**count优化**

MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高（前提是不适用where）；  
InnoDB 在执行 count(*) 时，需要把数据一行一行地从引擎里面读出来，然后累计计数。  

各种用法的性能：
- count(主键)：InnoDB引擎会遍历整张表，把每行的主键id值都取出来，返回给服务层，服务层拿到主键后，直接按行进行累加（主键不可能为空）
- count(字段)：没有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null，计数累加；有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加
- count(1)：InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一层，放一个数字 1 进去，直接按行进行累加
- count(* )：InnoDB 引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加

**按效率排序：count(字段) < count(主键) < count(1) < count(* )，所以尽量使用 count(* )**
   
**update优化（避免行锁升级为表锁 根据索引）**

**InnoDB 的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁**

如以下两条语句：  
`update student set no = '123' where id = 1;`，这句由于id有主键索引，所以只会锁这一行；  
`update student set no = '123' where name = 'test';`，这句由于name没有索引，所以会把整张表都锁住进行数据更新，解决方法是给name字段添加索引

## 锁
**锁是协调多个线程或进程并发访问某一资源的机制；数据也是一种共享资源，锁可以保证数据并发访问的一致性和完整性**

## 全局锁
备份时保证数据一致性
![](Pasted%20image%2020230904170845.png)
![](Pasted%20image%2020230904170838.png)

![](Pasted%20image%2020230904171510.png)
## 表级锁

### 表锁（读锁只能读不能写  写锁不能读也不能写）
![](Pasted%20image%2020230906203833.png)
### 元数据锁（MDL 为了避免DDL和DML冲突  修改表结构时加MDL写锁 ）
![](Pasted%20image%2020230906205136.png)

### 意向锁（为了避免DML时行锁和表锁的冲突）
**IS:当行锁为select查表示，表可以查不能改（shared_read√ write×）
IX:当行锁为修改行时，不能查也不能改**
![](Pasted%20image%2020230906210536.png)

![](Pasted%20image%2020230906212241.png)
## 行级锁
**防止修改和删除：行锁 
防止插入：间隙锁 
防止修改删除插入：临键锁**
![](Pasted%20image%2020230906215049.png)
![](Pasted%20image%2020230906220027.png)

![](Pasted%20image%2020230907104011.png)

![](Pasted%20image%2020230907111626.png)

# 存储引擎
## innodb存储引擎的存储结构
### 磁盘结构
![](Pasted%20image%2020230907133559.png)
缓存池
![](Pasted%20image%2020230907161640.png)
change buffer（二级索引）
![](Pasted%20image%2020230907162426.png)
哈希索引  日志缓冲区
![](Pasted%20image%2020230907163022.png)

![](Pasted%20image%2020230907165044.png)
### 磁盘结构
五个表空间：
**系统表空间 更改缓冲区
每个表的文件表空间 数据和索引
通用表空间 创建表时可以指定
撤销表空间 undo log日志
临时表空间  临时表**
![](Pasted%20image%2020230907170619.png)
![](Pasted%20image%2020230907170112.png)
双缓冲区和redo log（redo log buffer 和 redo log）
![](Pasted%20image%2020230907170048.png)
将数据刷新到磁盘
![](Pasted%20image%2020230907171830.png)

# 事务原理
**并发事务问题 脏读（读到未提交数据） 幻读（未读到数据但不能出入） 可重复读（两次读取数据不同 读到了已提交的事务）**
![](Pasted%20image%2020230907204327.png)
![](Pasted%20image%2020230907192350.png)
![](Pasted%20image%2020230907192341.png)
## redo log  持久性
redo log 如何保证数据的持久性？

>**1.DML之后脏数据不会直接刷新到磁盘而是将数据页的变化记录到redo log buffer中
2.commit之后，将redo log buffer中的记录刷新到磁盘是顺序IO叫WAL(提前写日志)
3.当脏数据刷新出错时，使用redo log file恢复保证了持久性**


![](Pasted%20image%2020230907195932.png)

- 思考为什么,用户commit后,不直接将缓冲池中修改的页数据(脏页)直接刷新回磁盘?但却又直接将内存中Log Buffer中redo log刷新回内存??

答: 直接将脏页刷新回磁盘,存在严重的性能问题.因为很多DML语句操作数据页的时候,都是随机的.直接操作磁盘,这属于大量的随机磁盘IO.而commit的时候都是先将log日志文件刷新到磁盘中,是因为他是日志文件,日志文件都是追加的形式.这是一种顺序的磁盘IO.这种机制叫做 WAL(writting - ahead - logging)不能做到对操作磁盘数据文件时的顺序IO,因为不同表数据在磁盘文件中的位置都是不一样的,切sql语句操作的属于随机操作,直接操作磁盘文件的话属于跳来跳去,而redo log重做日志文件,在磁盘中就一个位置,可以做到追加的形式来顺序IO.效率更高!

## undo log 原子性
![](Pasted%20image%2020230907201000.png)
## MVCC
![](Pasted%20image%2020230907202721.png)

## MVCC的实现原理
### 隐藏字段
![](Pasted%20image%2020230907204842.png)
### undo log版本链
![](Pasted%20image%2020230907210011.png)
### readview
![](Pasted%20image%2020230907210856.png)
![](Pasted%20image%2020230907211519.png)


### 详细解释
**RC:读取最新提交的数据，可以可重复读**
**将undo log版本链中头部数据中的trx_id和readview中的活跃未提交id比较找到最新提交的id**
![](Pasted%20image%2020230907212717.png)
**RR：读取的数据是一致的**

![](Pasted%20image%2020230907213338.png)
# 日志
## 错误日志
![](Pasted%20image%2020230907214243.png)
## 二进制日志
![](Pasted%20image%2020230907215441.png)



7
日志的实现？
隔离级别的区别？
undo log redo log?
索引？
B+树 B树？
垃圾回收 CMS？
类加载的阶段？
spring 中的设计模式 工厂 单例 代理 模板方法 策略模式 监听模式
AOP实现
TCP UDP的区别？
三次握手 四次挥手的过程？
并发编程(AQS)
redis的安全 高可用 单线程
